import { ref } from 'vue'
import { saveAs } from 'file-saver'
import axios from 'axios'
// note : the id is obtained after a post, it's a random string generated by DataFair's API -> _id attribute of a POST reponse
export const dataset = ref(new Map()) // key : id of all current versions of files/folders, value: object of metadatas values
export const hmDisplay = ref([]) // represent the array of histoModif.get(current id)
export const parentfolder = ref('0') // representing the current folder where the user is, it change when click on folder
export const loading = ref(false) // show a progress bar
export const percentage = ref(0) // value of the progress bar
export const displayError = ref(false) // display error v-snackbar if error on requests
export const errorMessage = ref('')

export async function getMetaData (dataUrl) {
  const url = `${dataUrl}/schema`
  const metaData = (await fetch(url))
  const reponse = await metaData.json()
  return reponse
}
export async function getValueField (key, dataUrl) {
  const url = `${dataUrl}/values/${key}`
  const metaData = await fetch((url), {
    method: 'GET',
    cache: 'no-cache',
    headers: {
      'Content-type': 'application/json'
    }
  })
  const reponse = await metaData.json()
  return reponse
}
// method : post all the files from the drag and drop zone
export async function postFilesDD (filesInput, dataUrl) {
  const files = []
  for (let i = 0; i < filesInput.length; i++) {
    files.push(filesInput.item(i))
  }
  const url = `${dataUrl}/lines`
  files.forEach(async (file) => {
    if (file.size === 0) { // we post a folder
      const doc = {
        nom: file.name,
        isfolder: true,
        parentfolder: parentfolder.value,
        version: '',
        description: '',
        _action: 'create'
      }
      const params = {
        method: 'POST',
        body: JSON.stringify(doc),
        headers: {
          'Content-type': 'application/json'
        }
      }
      try {
        const request = await fetch(url, params)
        if (request.status === 201) {
          const reponse = await request.json()
          dataset.value.set(reponse._id, doc)
        }
      } catch (e) {
        errorMessage.value = e.response.status + ' : ' + e.response.data
        displayError.value = true
      }
    } else { // we post a file
      const formData = new FormData()
      formData.append('attachment', file)
      formData.append('nom', file.name)
      formData.append('description', '')
      formData.append('version', '1')
      formData.append('taille', file.size)
      formData.append('isfolder', false)
      formData.append('parentfolder', parentfolder.value)
      formData.append('type_mime', file.type)
      formData.append('_action', 'create')
      const params = {
        url,
        method: 'POST',
        data: formData,
        onUploadProgress: function (progressEvent) {
          const { loaded, total } = progressEvent
          percentage.value = Math.floor((loaded * 100) / total)
          loading.value = true
        }
      }
      percentage.value = 0
      loading.value = true
      try {
        const request = await axios(params)
        loading.value = false
        if (request.status === 201) {
          const reponse = request.data
          const obj = {
            attachmentPath: reponse.attachmentPath,
            nom: file.name,
            taille: file.size,
            version: '1',
            description: '',
            isfolder: false,
            parentfolder: parentfolder.value,
            type_mime: file.type
          }
          dataset.value.set(reponse._id, obj)
        }
      } catch (e) {
        errorMessage.value = e.response.status + ' : ' + e.response.data
        displayError.value = true
        loading.value = false
      }
    }
  })
}

// method : post the document generated by the button
export async function postDocument (dataUrl, payload) {
  const { nom, description, version, file, isfolder } = payload
  const formData = new FormData()
  formData.append('attachment', file)
  formData.append('nom', nom)
  formData.append('description', description || '')
  formData.append('version', version || '1')
  formData.append('taille', file.size)
  formData.append('isfolder', isfolder)
  formData.append('parentfolder', parentfolder.value)
  formData.append('type_mime', file.type)
  formData.append('_action', 'create')
  const url = `${dataUrl}/lines`
  const params = {
    url,
    method: 'POST',
    data: formData,
    onUploadProgress: function (progressEvent) {
      const { loaded, total } = progressEvent
      percentage.value = Math.floor((loaded * 100) / total)
    }
  }
  percentage.value = 0
  loading.value = true
  let request
  try {
    request = await axios(params)
    if (request.status === 201) {
      const reponse = request.data
      const obj = {
        attachmentPath: reponse.attachmentPath,
        nom: reponse.nom,
        taille: file.size,
        version: reponse.version,
        description: reponse.description,
        isfolder,
        parentfolder: reponse.isfolder,
        type_mime: file.type
      }
      dataset.value.set(reponse._id, obj)
      loading.value = false
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
    loading.value = false
  }
}
// method : post a folder generated by the button
export async function postFolder (dataUrl, payload) {
  const { nom, description, version, file, isfolder } = payload
  const url = `${dataUrl}/lines`
  const doc = {
    nom,
    isfolder,
    parentfolder: parentfolder.value,
    version: version || '',
    description: description || '',
    _action: 'create'
  }
  const params = {
    method: 'POST',
    body: JSON.stringify(doc),
    headers: {
      'Content-type': 'application/json'
    }
  }
  try {
    const request = await fetch(url, params)
    if (request.status === 201) {
      const reponse = await request.json()
      dataset.value.set(reponse._id, doc)
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}
// method : get all lines from the data set, where their parent folder is equal to the actual folder
export async function getSet (dataUrl) {
  const url = `${dataUrl}/lines?q=${parentfolder.value}&q_fields=parentfolder&sort=-isfolder`
  const params = {
    method: 'GET',
    headers: {
      'Content-type': 'application/json'
    }
  }
  try {
    const request = await fetch(url, params)
    if (request.status === 200) {
      dataset.value.clear()
      const reponse = await request.json()
      let i
      for (i in reponse.results) {
        const data = reponse.results[i]
        const obj = {
          nom: data.nom,
          version: data.version,
          description: data.description,
          isfolder: data.isfolder,
          attachmentPath: data.attachmentPath,
          taille: data.taille,
          type_mime: data.type_mime,
          parentfolder: data.parentfolder
        }
        dataset.value.set(data._id, obj)
      }
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}
// method : get all the versions of a file, sorted by modification date
export async function getRevisions (dataUrl, ligneId) {
  const url = `${dataUrl}/lines/${ligneId}/revisions`
  try {
    const request = await fetch(url)
    if (request.status === 200) {
      const reponse = await request.json()
      hmDisplay.value = reponse.results.reverse()
      hmDisplay.value.forEach((value) => {
        const date = new Date(value._updatedAt)
        value._updatedAt = date.toLocaleString()
      })
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}
// method : delete file, API says to use bulk_lines to delete all of the versions of the file
export async function deleteFile (dataUrl, ligneId) {
  const url = `${dataUrl}/_bulk_lines`
  const doc = [{
    _action: 'delete',
    _id: ligneId
  }]
  const params = {
    method: 'POST',
    body: JSON.stringify(doc),
    headers: {
      'Content-type': 'application/json'
    }
  }
  try {
    const metaData = await fetch(url, params)
    if (metaData.status === 200) {
      dataset.value.delete(ligneId)
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}
// method : delete folder and all of its dependencies (all files/folders contained in it), it uses trackDependencies function to recursive deletes
export async function deleteFolder (dataUrl, ligneId) {
  const url = `${dataUrl}/lines/${ligneId}`
  const params = {
    method: 'DELETE',
    headers: {
      'Content-type': 'application/json'
    }
  }
  try {
    const metaData = await fetch(url, params)
    if (metaData.status === 204) {
      dataset.value.delete(ligneId)
      trackAndDeleteDependencies(dataUrl, ligneId)
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}

async function trackAndDeleteDependencies (dataUrl, ligneId) {
  const url = `${dataUrl}/lines?q=${ligneId}&q_fields=parentfolder`
  const params = {
    method: 'GET',
    headers: {
      'Content-type': 'application/json'
    }
  }
  const request = await fetch(url, params)
  if (request.status === 200) {
    const reponse = await request.json()
    const table = reponse.results
    for (let i = 0; i < table.length; i++) {
      if (table[i].isfolder) {
        deleteFolder(dataUrl, table[i]._id)
      } else {
        deleteFile(dataUrl, table[i]._id)
      }
    }
  }
}
// method : patch a data
// if folder, just patch it, for now only name and description field can be modified
// if file : if we just change name we do a simple patch else we do a post with more parameters in the dataform (action, id and attachmentPath)
// API will understand and automatically update the file and store the old version in revsions (see more on DataFair API)
export async function patchDocument (dataUrl, ligneId, payload, folder) {
  const { nom, description, version, file } = payload
  let url = `${dataUrl}/lines/`
  const data = dataset.value.get(ligneId)
  const formData = new FormData()
  let doc, request, reponse
  if (!folder) {
    if (file !== '') {
      let version
      try {
        version = parseInt(data.version) + 1
        version = version.toString()
      } catch (e) {
        version = '1'
      }
      formData.append('attachment', file)
      formData.append('nom', nom || data.nom)
      formData.append('description', description || data.description)
      formData.append('version', version)
      formData.append('taille', file.size)
      formData.append('isfolder', data.isfolder)
      formData.append('parentfolder', data.parentfolder)
      formData.append('type_mime', file.type)
      formData.append('_action', 'update')
      formData.append('_id', ligneId)
      formData.append('attachmentPath', data.attachmentPath)
      console.log(formData)
      const params = {
        url,
        method: 'POST',
        data: formData,
        onUploadProgress: function (progressEvent) {
          const { loaded, total } = progressEvent
          percentage.value = Math.floor((loaded * 100) / total)
        }
      }
      percentage.value = 0
      loading.value = true
      try {
        request = await axios(params)
        loading.value = false
        if (request.status === 200) {
          reponse = request.data
          doc = {
            attachmentPath: reponse.attachmentPath,
            nom: reponse.nom,
            taille: file.size,
            version: version || reponse.version,
            description: reponse.description,
            isfolder: false,
            parentfolder: reponse.parentfolder,
            type_mime: file.type
          }
          dataset.value.set(reponse._id, doc)
          loading.value = false
        }
      } catch (e) {
        errorMessage.value = e.response.status + ' : ' + e.response.data
        displayError.value = true
        loading.value = false
      }
    } else {
      url = `${dataUrl}/lines/${ligneId}`
      formData.append('nom', nom || data.nom)
      const params = {
        method: 'PATCH',
        body: formData
      }
      try {
        const request = await fetch(url, params)
        if (request.status === 200) {
          const reponse = await request.json()
          doc = {
            attachmentPath: reponse.attachmentPath,
            nom: reponse.nom,
            version: reponse.version,
            description: reponse.description,
            taille: reponse.taille,
            isfolder: reponse.isfolder,
            parentfolder: reponse.parentfolder,
            type_mime: reponse.type_mime
          }
          dataset.value.set(ligneId, doc)
        }
      } catch (e) {
        errorMessage.value = e.response.status + ' : ' + e.response.data
        displayError.value = true
      }
    }
  } else { // if we patch a folder
    url = `${dataUrl}/lines/${ligneId}`
    formData.append('nom', nom === '' ? data.nom : nom)
    formData.append('description', description === '' ? data.description : description)
    const params = {
      method: 'PATCH',
      body: formData
    }
    try {
      const request = await fetch(url, params)
      if (request.status === 200) {
        const reponse = await request.json()
        doc = {
          nom: reponse.nom,
          description: reponse.description,
          version: reponse.version,
          isfolder: reponse.isfolder,
          parentfolder: reponse.parentfolder
        }
        dataset.value.set(ligneId, doc)
      }
    } catch (e) {
      errorMessage.value = e.response.status + ' : ' + e.response.data
      displayError.value = true
    }
  }
}

// method : download the old file by using the saveAs method from the file-saver npm package
// path (string) : _id/hash/name of the file we want to download
export async function downloadFile (dataUrl, path, name) {
  const url = `${dataUrl}/attachments/${path}`
  try {
    const request = await fetch(url)
    if (request.status === 200) {
      const reponse = await request.blob()
      saveAs(reponse, name)
    }
  } catch (e) {
    errorMessage.value = e.response.status + ' : ' + e.response.data
    displayError.value = true
  }
}
