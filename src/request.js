import { ref } from 'vue'
import { saveAs } from 'file-saver'
import reactiveSearchParams from '@data-fair/lib/vue/reactive-search-params-global.js'
import { pathGED } from './content.js'
import axios from 'axios'
// note : the id is obtained after a post, it's a random string generated by DataFair's API -> _id attribute of a POST reponse
export const dataset = ref(new Map()) // key : id of all current versions of files/folders, value: object of metadatas values
export const arrayDisplay = ref(new Map()) // same as daatset but only containing files/folders to display
export const histoModif = ref(new Map()) // key : id, value: array(string) of date modification of previous and actual versions
export const hmDisplay = ref([]) // represent the array of histoModif.get(current id)
export const parentfolder = ref('') // representing the current folder where the user is, it change when click on folder
export const histoFichier = ref(new Map()) // key : id of the file displayed, value: array(string) of the ids of the previous versions
export const loading = ref(false) // show a progress bar
export const percentage = ref(0) // value of the progress bar
export const displayError = ref(false) // display error v-snackbar if error on requests
export async function getMetaData (dataUrl) {
  const url = `${dataUrl}/schema`
  const metaData = (await fetch(url))
  const reponse = await metaData.json()
  return reponse
}
export async function getValueField (key, dataUrl) {
  const url = `${dataUrl}/values/${key}`
  const metaData = await fetch((url), {
    method: 'GET',
    cache: 'no-cache',
    headers: {
      'Content-type': 'application/json'
    }
  })
  const reponse = await metaData.json()
  return reponse
}
// method : post all the files from the drag and drop zone
export async function postFilesDD (filesInput, dataUrl) {
  const files = []
  for (let i = 0; i < filesInput.length; i++) {
    files.push(filesInput.item(i))
  }
  const url = `${dataUrl}/lines`
  files.forEach(async (file) => {
    if (file.size === 0) { // we post a folder
      const doc = {
        nom: file.name,
        isfolder: true,
        parentfolder: parentfolder.value,
        version: '',
        description: '',
        isoldversion: false
      }
      const params = {
        method: 'POST',
        body: JSON.stringify(doc),
        headers: {
          'Content-type': 'application/json'
        }
      }
      const request = await fetch(url, params)
      const reponse = await request.json()
      if (request.status === 201) {
        dataset.value.set(reponse._id, doc)
        arrayDisplay.value.set(reponse._id, doc)
      } else {
        displayError.value = true
      }
      return reponse
    } else { // we post a file
      const formData = new FormData()
      formData.append('attachment', file)
      formData.append('nom', file.name)
      formData.append('description', '')
      formData.append('version', '1')
      formData.append('taille', file.size)
      formData.append('isfolder', false)
      formData.append('parentfolder', parentfolder.value)
      formData.append('type_mime', file.type)
      formData.append('historique_modification', file.lastModified.toString())
      formData.append('isoldversion', false)
      formData.append('idoldversions', '')
      const params = {
        url,
        method: 'POST',
        data: formData,
        onUploadProgress: function (progressEvent) {
          const { loaded, total } = progressEvent
          percentage.value = Math.floor((loaded * 100) / total)
        }
      }
      percentage.value = 0
      loading.value = true
      const request = await axios(params)
      const reponse = request.data
      loading.value = false
      if (request.status === 201) {
        const obj = {
          attachmentPath: file.name,
          nom: file.name,
          taille: file.size,
          version: '1',
          description: '',
          isfolder: false,
          parentfolder: parentfolder.value,
          type_mime: file.type
        }
        dataset.value.set(reponse._id, obj)
        arrayDisplay.value.set(reponse._id, obj)
        histoModif.value.set(reponse._id, [file.lastModified.toString()])
        histoFichier.value.set(reponse._id, [])
      } else {
        displayError.value = true
      }
      return reponse
    }
  })
}
// method : post the document generated by the button
export async function postDocument (dataUrl, payload) {
  const { nom, description, version, file, isfolder } = payload
  const formData = new FormData()
  formData.append('attachment', file)
  formData.append('nom', nom)
  formData.append('description', description || '')
  formData.append('version', version || '')
  formData.append('taille', file.size)
  formData.append('isfolder', isfolder)
  formData.append('parentfolder', parentfolder.value)
  formData.append('type_mime', file.type)
  formData.append('historique_modification', file.lastModified.toString())
  formData.append('isoldversion', false)
  formData.append('idoldversions', '')

  const url = `${dataUrl}/lines`
  const params = {
    url,
    method: 'POST',
    data: formData,
    onUploadProgress: function (progressEvent) {
      const { loaded, total } = progressEvent
      percentage.value = Math.floor((loaded * 100) / total)
    }
  }
  percentage.value = 0
  loading.value = true
  const request = await axios(params)
  const reponse = request.data
  loading.value = false
  if (request.status === 201) {
    const obj = {
      attachmentPath: file.name,
      nom,
      taille: file.size,
      version: version || '',
      description: description || '',
      isfolder,
      parentfolder: parentfolder.value,
      type_mime: file.type
    }
    dataset.value.set(reponse._id, obj)
    arrayDisplay.value.set(reponse._id, obj)
    histoModif.value.set(reponse._id, [file.lastModified.toString()])
    histoFichier.value.set(reponse._id, [])
  } else {
    displayError.value = true
  }
  return reponse
}
// method : post a folder generated by the button
export async function postFolder (dataUrl, payload) {
  const { nom, description, version, file, isfolder } = payload
  const url = `${dataUrl}/lines`
  const doc = {
    nom,
    isfolder,
    parentfolder: parentfolder.value,
    version: version || '',
    description: description || '',
    isoldversion: false
  }
  const params = {
    method: 'POST',
    body: JSON.stringify(doc),
    headers: {
      'Content-type': 'application/json'
    }
  }
  const request = await fetch(url, params)
  const reponse = await request.json()
  if (request.status === 201) {
    dataset.value.set(reponse._id, doc)
    arrayDisplay.value.set(reponse._id, doc)
  } else { displayError.value = true }
  return reponse
}
// method : get all lines from the data set, then store those who are not oldVersion on the dataset map
export async function getDataSet (dataUrl) {
  const url = `${dataUrl}/lines`
  const metaData = (await fetch(url))
  const reponse = await metaData.json()
  let i
  for (i in reponse.results) {
    if (!reponse.results[i].isoldversion) { // store the file if in the array map if its not an old version
      const fileName = reponse.results[i].isfolder ? '' : reponse.results[i].attachmentPath.replace(/.*\//, '')
      const obj = {
        attachmentPath: fileName,
        nom: reponse.results[i].nom,
        taille: reponse.results[i].taille,
        version: reponse.results[i].version,
        isfolder: reponse.results[i].isfolder,
        parentfolder: reponse.results[i].parentfolder,
        type_mime: reponse.results[i].type_mime,
        description: reponse.results[i].description,
        isoldversion: reponse.results[i].isoldversion
      }
      dataset.value.set(reponse.results[i]._id, obj)

      if (reactiveSearchParams.parentFolder !== undefined && reactiveSearchParams.parentFolder === reponse.results[i].parentfolder) {
        arrayDisplay.value.set(reponse.results[i]._id, obj)
      } else if (reactiveSearchParams.parentFolder === undefined && (reponse.results[i].parentfolder === undefined || reponse.results[i].parentfolder === '')) {
        arrayDisplay.value.set(reponse.results[i]._id, obj)
      }
      if (!reponse.results[i].isfolder) {
        histoModif.value.set(reponse.results[i]._id, reponse.results[i].historique_modification.split(','))
        histoFichier.value.set(reponse.results[i]._id, reponse.results[i].idoldversions.split(','))
      }
    }
  }
  if (reactiveSearchParams.parentFolder !== undefined) {
    const tab = reactiveSearchParams.pathGED.split(',')
    for (let i = 0; i < tab.length; i++) {
      pathGED.value.set(tab[i], dataset.value.get(tab[i]).nom)
    }
  }
  return reponse.results
}
// method : delete file and its old versions if exists (which can be find in histoFichier)
export async function deleteFile (dataUrl, ligneId) {
  let url = `${dataUrl}/lines/${ligneId}`
  const params = {
    method: 'DELETE',
    headers: {
      'Content-type': 'application/json'
    }
  }
  const metaData = await fetch(url, params)
  const reponse = await metaData.text()
  if (metaData.status === 204) {
    dataset.value.delete(ligneId)
    arrayDisplay.value.delete(ligneId)
    histoModif.value.delete(ligneId)
    const tabId = histoFichier.value.get(ligneId)
    console.log(tabId)
    for (let i = tabId[0] === '' ? 1 : 0; i < tabId.length; i++) {
      url = `${dataUrl}/lines/${tabId[i]}`
      const metaData2 = await fetch(url, params)
      const reponse2 = await metaData2.text()
    }
    histoFichier.value.delete(ligneId)
  } else {
    displayError.value = true
  }
  return reponse
}
// method : delete folder and all of its dependencies (all files/folders contained in it), it uses trackDependencies function to recursive deletes
export async function deleteFolder (dataUrl, ligneId) {
  const url = `${dataUrl}/lines/${ligneId}`
  const params = {
    method: 'DELETE',
    headers: {
      'Content-type': 'application/json'
    }
  }
  const metaData = await fetch(url, params)
  if (metaData.status === 204) {
    histoModif.value.delete(ligneId)
    dataset.value.delete(ligneId)
    arrayDisplay.value.delete(ligneId)
    trackAndDeleteDependencies(dataUrl, ligneId)
  } else {
    displayError.value = true
  }
  const reponse = await metaData.text()
  return reponse
}

async function trackAndDeleteDependencies (dataUrl, ligneId) {
  dataset.value.forEach((value, key) => {
    if (value.isfolder === true && value.parentfolder === ligneId) {
      deleteFolder(dataUrl, key)
    } else {
      if (value.parentfolder === ligneId) {
        deleteFile(dataUrl, key)
      }
    }
  })
}
// method : if we patch a folder or metadatas of a file, we just patch basically (patch)
// if we update a file, we post a new one, set isOldVersion parameter at true for the previous one
// and we update histoFichier and histoModif maps by reading the previous value and update it with the id of the file we updated (post & patch)
export async function patchDocument (dataUrl, ligneId, payload, folder) {
  const { nom, description, versiont, file } = payload
  let url = `${dataUrl}/lines/`
  const data = dataset.value.get(ligneId)
  let formData = new FormData()
  let doc, request, reponse
  if (!folder) {
    if (file !== '') {
      const hm = histoModif.value.get(ligneId)
      hm.push(file.lastModified.toString())
      const listId = histoFichier.value.get(ligneId)
      if (listId[0] === '') {
        listId[0] = ligneId
      } else {
        listId.push(ligneId)
      }
      let version
      try {
        version = parseInt(data.version) + 1
        version = version.toString()
      } catch (e) {
        version = '1'
      }
      formData.append('attachment', file)
      formData.append('nom', nom || data.nom)
      formData.append('description', description || data.description)
      formData.append('version', version)
      formData.append('taille', file.size)
      formData.append('isfolder', data.isfolder)
      formData.append('parentfolder', data.parentfolder)
      formData.append('type_mime', file.type)
      formData.append('historique_modification', histoModif.value.get(ligneId).toString())
      formData.append('isoldversion', false)
      formData.append('idoldversions', listId.toString())
      const params = {
        url,
        method: 'POST',
        data: formData,
        onUploadProgress: function (progressEvent) {
          const { loaded, total } = progressEvent
          percentage.value = Math.floor((loaded * 100) / total)
        }
      }
      percentage.value = 0
      loading.value = true
      request = await axios(params)
      reponse = request.data
      loading.value = false
      if (request.status === 201) {
        doc = {
          attachmentPath: file.name,
          nom: nom || data.nom,
          taille: file.size,
          version: version || data.version,
          description: description || data.description,
          isfolder: false,
          parentfolder: data.parentfolder,
          type_mime: file.type,
          isoldversion: false
        }
        dataset.value.set(reponse._id, doc)
        arrayDisplay.value.set(reponse._id, doc)
        histoModif.value.set(reponse._id, reponse.historique_modification.split(','))
        histoFichier.value.set(reponse._id, reponse.idoldversions.split(','))
        dataset.value.delete(ligneId)
        histoModif.value.delete(ligneId)
        arrayDisplay.value.delete(ligneId)
        histoFichier.value.delete(ligneId)
        // now set the oldversion parameter at true for the old version
        url = `${dataUrl}/lines/${ligneId}`
        formData = new FormData()
        formData.append('isoldversion', true)
        const params = {
          method: 'PATCH',
          body: formData
        }
        request = await fetch(url, params)
        reponse = await request.json()
      } else {
        displayError.value = true
      }
    } else {
      url = `${dataUrl}/lines/${ligneId}`
      formData.append('nom', nom || data.nom)
      formData.append('description', description || data.description)
      formData.append('version', versiont || data.version)
      const params = {
        method: 'PATCH',
        body: formData
      }
      const request = await fetch(url, params)
      if (request.status === 200) {
        doc = {
          attachmentPath: data.attachmentPath,
          nom: nom || data.nom,
          version: versiont || data.version,
          description: description || data.description,
          taille: data.taille,
          isfolder: data.isfolder,
          parentfolder: data.parentfolder,
          type_mime: data.type_mime,
          isoldversion: data.isoldversion
        }
        dataset.value.set(ligneId, doc)
        arrayDisplay.value.set(ligneId, doc)
      } else {
        displayError.value = true
      }
      const reponse = await request.json()
      return reponse
    }
  } else {
    url = `${dataUrl}/lines/${ligneId}`
    doc = {
      nom: nom === '' ? data.nom : nom,
      description: description === '' ? data.description : description,
      version: version === '' ? data.version : version,
      isfolder: data.isfolder,
      parentfolder: data.parentfolder
    }
    formData.append('nom', nom === '' ? data.nom : nom)
    formData.append('description', description === '' ? data.description : description)
    formData.append('version', versiont === '' ? data.version : versiont)
    const params = {
      method: 'PATCH',
      body: formData
    }
    const request = await fetch(url, params)
    if (request.status === 200) {
      dataset.value.set(ligneId, doc)
      arrayDisplay.value.set(ligneId, doc)
    } else {
      displayError.value = true
    }
    const reponse = await request.json()
    return reponse
  }
}
// method : download the old file, his id is store in histoFichier map at indice index
// then we do a get to access the attachmentPath and we download the file using saveAs from file-saver npm package
export async function downloadFile (dataUrl, ligneId, indice) {
  const idov = histoFichier.value.get(ligneId)[indice]
  let url = `${dataUrl}/lines/${idov}`
  let request = await fetch(url)
  const reponse1 = await request.json()
  const link = reponse1.attachmentPath
  url = `${dataUrl}/attachments/${link}`
  request = await fetch(url)
  const reponse2 = await request.blob()
  saveAs(reponse2, reponse1.nom)
}
